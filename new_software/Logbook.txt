subroutine steering_species_diag(sim, report_spec, particle_name, command_name, new_value, ierr)      
        implicit none
        
        ! Argumentos
        class(t_simulation), intent(inout) :: sim
        character(*), intent(in) :: particle_name      ! Nome da partíula ex: sodium, etc.
        character(*), intent(in) :: command_name      ! Nome do comando (ex: "ndump_fac", "n_ave", etc.)
        character(*), intent(in) :: report_spec       ! Especificação do relatório (ex: "e3", "e2, line, x1, 64, 96")
        integer, dimension(:), intent(in) :: new_value ! Novo valor (pode ser escalar ou array)
        integer, intent(out) :: ierr                  ! Código de erro (0 = sucesso)
        
        ! Variáveis locais
        type(t_species), pointer :: diag_species
        type(t_vdf_report), pointer :: report
        type(t_vdf_report_item), pointer :: item
        character(len=:), allocatable :: quant, details
        integer :: pos, item_type, direction, id
        logical :: found, is_tavg
        integer, dimension(2) :: gipos
        integer ::  n_dimensions 
        logical :: found_name
        
        ! Inicializa ponteiros e variáveis
        ierr = 0
        found_name = .false.

        diag_species => sim%part%species  ! Start with first species in list

        do while (associated(diag_species))
            if (trim(diag_species%name) == trim(particle_name)) then
                found_name = .true.
                exit
            end if
            diag_species => diag_species%next  ! Move to next species in list
        end do

        if (.not. found_name) then
            ierr = 1
            if (mpi_node() == 0) then
                print *, "DEBUG - Species particle id not found: ", trim(particle_name)
            end if
            return
        end if

        report => diag_species%diag%reports

        n_dimensions = sim%g_space%x_dim ! Sets number of dimensions for spacial averages
        
        ! Passo 1: Parse da especificação do relatório
        pos = index(report_spec, ',')
        if (pos > 0) then
            quant = report_spec(1:pos-1)        ! Assign substring first
            quant = trim(adjustl(quant))        ! Then trim/adjust
            details = report_spec(pos+1:)       ! Assign substring first
            details = trim(adjustl(details))    ! Then trim/adjust
        else
            quant = trim(adjustl(report_spec))
            details = ""
        end if
        
        ! Passo 2: Encontrar o relatório principal (quantidade)
        found = .false.
        do while (associated(report) .and. .not. found)
            if (root(sim%no_co)) then
                print *, "DEBUG - Found: ", report%name
            endif
            if (trim(report%name) == quant) then
                found = .true.
                exit
            end if
            report => report%next
        end do
        
        if (.not. found) then
            ierr = -1  ! Relatório não encontrado
            return
        end if
        
        ! Passo 3: Parse dos detalhes (se existirem)
        call parse_report_spec(report_spec, quant, details, item_type, direction, gipos, is_tavg)
        
       ! Passo 4: Encontrar item específico
        if (item_type > 0) then
            found = .false.
            item => report%list
            do while (associated(item) .and. .not. found)
                if (item%type == item_type) then
                    if (item_type == p_line .or. item_type == p_slice) then
                        ! Corrigido: usar .eqv. para lógicos
                        if (item%direction == direction .and. &
                            all(item%gipos == gipos) .and. &
                            item%tavg .eqv. is_tavg) then
                            found = .true.
                            exit
                        end if
                    else
                        ! Corrigido: usar .eqv. para lógicos
                        if (item%tavg .eqv. is_tavg) then
                            found = .true.
                            exit
                        end if
                    end if
                end if
                item => item%next
            end do
        end if
        
        ! Passo 5: Aplicar modificações conforme o comando
        select case (trim(command_name))
            ! Comandos globais (afetam todo o relatório)
            case ("ndump_fac")
                report%ndump(p_full) = new_value(1)
            case ("ndump_fac_ave")
                report%ndump(p_savg) = new_value(1)
                report%ndump(p_senv) = new_value(1)
            case ("ndump_fac_lineout")
                report%ndump(p_line) = new_value(1)
                report%ndump(p_slice) = new_value(1)
            
            ! Outras frequências de dump

            case ("ndump_fac_ene")
                diag_species%diag%ndump_fac_ene  = new_value(1)
            case ("ndump_fac_heatflux")
                diag_species%diag%ndump_fac_heatflux = new_value(1)
            case ("ndump_fac_temp")
                diag_species%diag%ndump_fac_temp = new_value(1)
            case ("ndump_fac_raw")  
                diag_species%diag%ndump_fac_raw = new_value(1)

            ! Comandos para itens específicos

            case ("n_ave")
                if (size(new_value) >= n_dimensions) then
                    report%n_ave(1:n_dimensions) = new_value(1:n_dimensions)
                else
                    ierr = -3  ! Tamanho inválido
                    if (mpi_node() == 0) then
                        print *, "DEBUG - Invalid size for n_ave in steering_emf_diag"
                    endif
                end if
            case ("n_tavg")
                report%n_tavg = new_value(1)
                if (report%n_tavg > 0 .and. .not. associated(report%tavg_data%f1)) then
                    call report%tavg_data%new( &
                        sim%grid%x_dim, &       ! Dimensão espacial
                        1, &                    ! f_dim
                        sim%grid%g_nx, &        ! nx
                        sim%emf%e%gc_num(), &   ! gc_num (CORRECTED)
                        sim%emf%e%dx(), &       ! dx
                        .true. &                ! zero
                    )
                endif

            case ("gipos")
                if (associated(item) .and. size(new_value) >= size(item%gipos)) then
                    item%gipos = new_value(1:size(item%gipos))
                else
                    ierr = -4  ! Item inválido ou tamanho incorreto
                    if (mpi_node() == 0) then
                        print *, "DEBUG - Invalid item or size mismatch for gipos in steering_emf_diag"
                    endif
                end if                

            case ("prec")
                report%prec = new_value(1)  ! Atualiza precisão do relatório

            ! Add here code for other commands 

            case ("raw_gamma_limit")
                diag_species%diag%raw_gamma_limit = new_value(1)
            case ("raw_fraction")
                diag_species%diag%raw_fraction = new_value(1)
            case ("ndump_fac_tracks")
                diag_species%diag%ndump_fac_tracks = new_value(1)
            case ("n_start_tracks")
                diag_species%diag%n_start_tracks = new_value(1)

            case default
                ierr = -5  ! Comando desconhecido
        end select
        
    end subroutine steering_species_diag

    !-----------------------------------------------------------------------------------------
    !       Add species reports
    !-----------------------------------------------------------------------------------------
    subroutine add_species_report(sim, input_string, name, report_type)
        type(t_restart_handle) :: restart_handle
        character(len=*), intent(in) :: input_string
        class(t_simulation), intent(inout) :: sim
        integer :: ierr
        character(*), intent(in) :: name
        character(*), intent(in) :: report_type  ! "normal", "cell_avg", or "udist"
        type(t_species), pointer :: type_species
        type(t_diag_species), pointer :: diag_species

        type(t_vdf_report), pointer :: report
        logical :: found_name

        ! Inicializa ponteiros e variáveis
        ierr = 0
        found_name = .false.

        type_species => sim%part%species  ! Start with first species in list

        ! As there is a linked list of species, we need to find the one with the given name
        do while (associated(type_species))
            if (trim(type_species%name) == trim(name)) then
                found_name = .true.
                exit
            end if
            type_species => type_species%next  ! Move to next species in list
        end do

        if (.not. found_name) then
            ierr = 1
            if (mpi_node() == 0) then
                print *, "DEBUG - Species particle id not found: ", trim(name)
            end if
            return
        end if

        ! Get the diag_species structure from the species
        diag_species => type_species%diag

        ! Select the appropriate report list based on report_type
        select case (trim(report_type))
            case ("normal")
                call add_report(diag_species%reports, trim(input_string), diag_species%report_quants, &
                            sim%g_space%x_dim, ierr)
                report => diag_species%reports
            case ("cell_avg")
                call add_report(diag_species%rep_cell_avg, trim(input_string), diag_species%report_quants, &
                            sim%g_space%x_dim, ierr)
                report => diag_species%rep_cell_avg
            case ("udist")
                call add_report(diag_species%rep_udist, trim(input_string), diag_species%report_quants, &
                            sim%g_space%x_dim, ierr)
                report => diag_species%rep_udist
            case default
                ierr = 1
                if (mpi_node() == 0) then
                    print *, "Invalid report type: ", trim(report_type)
                endif
                return
        end select

        ! Initialize the report if it was added successfully
        if (ierr == 0) then
            ! Initialize diagnostics for this species
            call diag_species % init( &
                trim(type_species%name), &          ! spec_name
                sim%g_space%x_dim, &                ! n_x_dim
                0, &                                ! ndump_fac (default value)
                interpolation( sim%part ), &        ! interpolation
                .false., &                          ! restart
                restart_handle )                    ! restart_handle

            ! Find the newly added report and initialize time averaging if needed
            do while (associated(report))
                if (trim(report%name) == trim(input_string)) then
                    if (report%n_tavg > 0) then
                        ! Initialize tavg_data with grid parameters
                        call report%tavg_data%new( &
                            sim%grid%x_dim, &       ! Spatial dimension
                            1, &                     ! f_dim (scalar field)
                            sim%grid%g_nx, &         ! Global grid size
                            sim%emf%e%gc_num(), &    ! Guard cells
                            sim%emf%e%dx(), &        ! Cell size
                            .true. &                 ! Zero the field
                        )
                    endif
                    exit
                endif
                report => report%next
            enddo
        end if

        ! Report status
        if (ierr /= 0) then
            if (mpi_node() == 0) then
                print *, "Error adding ", trim(report_type), " report: ", trim(input_string)
            endif
        else
            if (mpi_node() == 0) then
                print *, "Added new ", trim(report_type), " report: ", trim(input_string)
            endif
        endif
    end subroutine add_species_report